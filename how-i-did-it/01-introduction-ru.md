# BSimple. Записки сумасшедшего, или как я решил написать компилятор.

## Введение

Каждый программист должен написать свой язык программирования. В какой-то момент моей жизни я в шутку написал в Twitter, что, если мой твит наберёт 666 лайков, я реализую лисп-подобный язык программирования на Scala. Написал — и не думал о последствиях. Позже мой телефон просто разрывался от уведомлений, и я понял, что попал.

Лисп-подобный язык был написан, работал и, вроде как, даже неплохо справлялся со своей задачей — насколько это вообще возможно для подобных реализаций Лиспа. Но одно дело — сделать интерпретатор, описав его на типах в монструозном языке вроде Scala, и совсем другое — создать "НАСТОЯЩИЙ" компилятор и язык программирования.

А моё увлечение ретро-компьютерами (и псевдоретро-компьютерами) заставляло меня думать, что компилятор как минимум должен уметь компилировать под них, а как максимум — работать на них.

Задача весёлая, но, если смотреть на неё целиком, выглядит пугающе. Поэтому, если у тебя тоже есть такой незакрытый гештальт и ты хочешь создать свой язык программирования, я покажу путь, который прошёл сам. Но не считай это учебником по написанию компиляторов.

### Компилятор BSimple

Компилятор BSimple — это не то, что можно назвать хорошим компилятором. Ни с точки зрения архитектуры, ни с точки зрения эффективности. Более того, в него изначально были заложены определённые ограничения: он не строит дерево исходного кода, а сразу генерирует ассемблерный листинг. Компиляция в чистый машинный код вряд ли была бы намного сложнее на практике, но такой подход позволил срезать некоторые углы, связанные с линковкой проекта.

### Что за язык программирования BSimple?

Это простой компилируемый язык программирования, который синтаксически похож на B и C. Он имеет всего один тип данных — машинное слово. Переменные могут быть определены как глобально, так и на стеке. Формат вызова функций — cdecl (с параметрами на стеке).

Операции описаны через стек и два регистра (аккумулятор и дополнительный регистр; в случае процессора Z80 — HL и DE).

### Как выглядит программа на BSimple?

import "../lib/startup.i"
import "../lib/stdlib.i"

main() {
  var s;  # S will contain pointer to string literal
   s = "Example string";
   printf("Hello, world!\r\n");
   printf("\r\nNum parsers: %b\r\n", parse_num("11100111", 2));
   printf("%s\r\n", s);
}


Для любого человека, писавшего на C-подобных языках, программа выглядит достаточно понятно. Единственный момент, требующий пояснения, — это конструкция import. Она просто включает в листинг подключение ассемблерного кода. Таким образом подключается стартовый код и рантайм.

На первых этапах даже сборку проекта из нескольких файлов можно обеспечить через ассемблер и подобный импорт скомпилированных файлов, что позволит мне первое время не думать о линкере.

